# Attendace-Capture-and-Management
















IBM - PROJECT


faceUP























Group:
Aryan Parekh    - 60004190013
Kartik Suvarna  - 60004190060
Mayav Antani   - 60004190066
Rashi Lodha      - 60003190041
Soham Desai     - 60003190058





Table of Contents





















1.1 Aim:

We know that the attendance system used in colleges is getting better at a very fast pace. The aim of our project is to keep up with and improve the speed and quality of the attendance system by adding face recognition to it. Attendance capturing and management is the main feature of our project.

1.2 Technologies:

CMAKE

CMake is a collection of open-source and cross-platform tools used to build and distribute software. In recent years it has become a de-facto standard for C and C++ applications, so the time has come for a lightweight introductory article on the subject.

DLIB

Dlib is a general purpose cross-platform open source software library written in the C++ programming language. Its design is heavily influenced by ideas from design by contract and component-based software engineering. This means it is, first and foremost, a collection of independent software components, each accompanied by extensive documentation and thorough debugging modes.

JUPYTER

The Jupyter Notebook is an open source web application that you can use to create and share documents that contain live code, equations, visualizations, and text. Jupyter Notebook is maintained by the people at Project Jupyter.

MATPLOTLIB

Matplotlib is an amazing visualization library in Python for 2D plots of arrays. Matplotlib is a multi-platform data visualization library built on NumPy arrays and designed to work with the broader SciPy stack. 
One of the greatest benefits of visualization is that it allows us visual access to huge amounts of data in easily digestible visuals. Matplotlib consists of several plots like line, bar, scatter, histogram etc.

NUMPY

NumPy is a Python library used for working with arrays.
It also has functions for working in domain of linear algebra, fourier transform, and matrices.
NumPy was created in 2005 by Travis Oliphant. It is an open source project and you can use it freely.
NumPy stands for Numerical Python.

NLTK

NLTK (Natural Language Toolkit) is the go-to API for NLP (Natural Language Processing) with Python. It is a really powerful tool to preprocess text data for further analysis like with ML models for instance. It helps convert text into numbers, which the model can then easily work with. This is the first part of a basic introduction to NLTK for getting your feet wet and assumes some basic knowledge of Python.

OPENCV-PYTHON

OpenCV-Python is a library of Python bindings designed to solve computer vision problems.
Python is a general purpose programming language started by Guido van Rossum that became very popular very quickly, mainly because of its simplicity and code readability. It enables the programmer to express ideas in fewer lines of code without reducing readability.
Compared to languages like C/C++, Python is slower. That said, Python can be easily extended with C/C++, which allows us to write computationally intensive code in C/C++ and create Python wrappers that can be used as Python modules. This gives us two advantages: first, the code is as fast as the original C/C++ code (since it is the actual C++ code working in background) and second, it is easier to code in Python than C/C++. OpenCV-Python is a Python wrapper for the original OpenCV C++ implementation.
OpenCV-Python makes use of Numpy, which is a highly optimized library for numerical operations with a MATLAB-style syntax. All the OpenCV array structures are converted to and from Numpy arrays. This also makes it easier to integrate with other libraries that use Numpy such as SciPy and Matplotlib.

PANDAS

Pandas is a Python library used for working with data sets.
It has functions for analyzing, cleaning, exploring, and manipulating data.
The name "Pandas" has a reference to both "Panel Data", and "Python Data Analysis" and was created by Wes McKinney in 2008.
Pandas allows us to analyze big data and make conclusions based on statistical theories.
Pandas can clean messy data sets, and make them readable and relevant.
Relevant data is very important in data science.

SCIKIT-LEARN

Scikit-learn (Sklearn) is the most useful and robust library for machine learning in Python. It provides a selection of efficient tools for machine learning and statistical modeling including classification, regression, clustering and dimensionality reduction via a consistence interface in Python. This library, which is largely written in Python, is built upon NumPy, SciPy and Matplotlib.


1.3 Software Architecture:

HTML

HTML stands for HyperText Markup Language. It is used to design web pages using a markup language. HTML is the combination of Hypertext and Markup language. Hypertext defines the link between the web pages. A markup language is used to define the text document within a tag which defines the structure of web pages. This language is used to annotate (make notes for the computer) text so that a machine can understand it and manipulate text accordingly. Most markup languages (e.g. HTML) are human-readable. The language uses tags to define what manipulation has to be done on the text. HTML is a markup language used by the browser to manipulate text, images, and other content, in order to display it in the required format.
Elements and Tags: HTML uses predefined tags and elements which tell the browser how to properly display the content. Remember to include closing tags. If omitted, the browser applies the effect of the opening tag until the end of the page. 
HTML page structure: The basic structure of an HTML page is laid out below. It contains the essential building-block elements (i.e. doctype declaration, HTML, head, title, and body elements) upon which all web pages are created.
Features of HTML: 
It is easy to learn and easy to use.
It is platform-independent.
Images, videos, and audio can be added to a web page.
Hypertext can be added to text.
It is a markup language.
Advantages: 
HTML is used to build websites.
It is supported by all browsers.
It can be integrated with other languages like CSS, JavaScript, etc.
Disadvantages: 
HTML can only create static web pages. For dynamic web pages, other languages have to be used.
A large amount of code has to be written to create a simple web page.
The security feature is not good.

CSS

Cascading Style Sheets, fondly referred to as CSS, is a simply designed language intended to simplify the process of making web pages presentable. CSS allows you to apply styles to web pages. More importantly, CSS enables you to do this independent of the HTML that makes up each web page.
CSS is easy to learn and understood, but it provides powerful control over the presentation of an HTML document.
ADVANTAGES OF CSS? 
CSS saves time: You can write CSS once and reuse the same sheet in multiple HTML pages.
Easy Maintenance: To make a global change simply change the style, and all elements in all the webpages will be updated automatically.
Search Engines: CSS is considered a clean coding technique, which means search engines won’t have to struggle to “read” its content.
Superior styles to HTML: CSS has a much wider array of attributes than HTML, so you can give a far better look to your HTML page in comparison to HTML attributes.
Offline Browsing: CSS can store web applications locally with the help of an offline cache. Using this we can view offline websites.

Django

Django is a web application framework written in Python programming language. It is based on the MVT (Model View Template) design pattern. Django is very demanding due to its rapid development feature. It takes less time to build an application after collecting client requirements.
This framework uses a famous tagline:The web framework for perfectionists with deadlines.
By using Django, we can build web applications in very less time. Django is designed in such a manner that it handles much of the configuration automatically, so we can focus on application development only.
Rapid Development
Django was designed with the intention to make a framework which takes less time to build web applications. The project implementation phase is very time taken but Django creates it rapidly.
Secure
Django takes security seriously and helps developers to avoid many common security mistakes, such as SQL injection, cross-site scripting, cross-site request forgery etc. Its user authentication system provides a secure way to manage user accounts and passwords.
Scalable
Django is scalable in nature and has the ability to quickly and flexibly switch from small to large scale application projects.
Fully loaded
Django includes various helping task modules and libraries which can be used to handle common Web development tasks. Django takes care of user authentication, content administration, site maps, RSS feeds etc.
Versatile
Django is versatile in nature which allows it to build applications for different-different domains. Nowadays, Companies are using Django to build various types of applications like: content management systems, social networks sites or scientific computing platforms etc.
Open Source
Django is an open source web application framework. It is publicly available without cost. It can be downloaded with source code from the public repository. Open source reduces the total cost of the application development.
SQL CREATE TABLE
Vast and Supported Community
Django is one of the most popular web frameworks. It has a widely supportive community and channels to share and connect.

JAVASCRIPT

JavaScript is a lightweight, cross-platform, and interpreted scripting language. It is well-known for the development of web pages, many non-browser environments also use it. JavaScript can be used for Client-side developments as well as Server-side developments. JavaScript contains a standard library of objects, like Array, Date, and Math, and a core set of language elements like operators, control structures, and statements.
Client-side: It supplies objects to control a browser and its Document Object Model (DOM). Like if client-side extensions allow an application to place elements on an HTML form and respond to user events such as mouse clicks, form input, and page navigation. Useful libraries for the client-side are AngularJS, ReactJS, VueJS and so many others.
Server-side: It supplies objects relevant to running JavaScript on a server. Like if the server-side extensions allow an application to communicate with a database, and provide continuity of information from one invocation to another of the application, or perform file manipulations on a server. The useful framework which is the most famous these days is node.js.
JavaScript can be added to your HTML file in two ways:
Internal JS: We can add JavaScript directly to our HTML file by writing the code inside the <script> tag. The <script> tag can either be placed inside the <head> or the <body> tag according to the requirement.
External JS: We can write JavaScript code in other file having an extension .js and then link this file inside the <head> tag of the HTML file in which we want to add this code.

2.1.1 Functional requirements:

alabaster==0.7.12
anaconda-client==1.7.2
anaconda-navigator==1.9.7
anaconda-project==0.8.3
appdirs==1.4.4
asgiref==3.3.4
asn1crypto==1.0.1
astroid==2.3.1
astropy==3.2.1
atomicwrites==1.3.0
attrs==19.2.0
Babel==2.7.0
backcall==0.1.0
backports.functools-lru-cache==1.5
backports.os==0.1.1
backports.shutil-get-terminal-size==1.0.0
backports.tempfile==1.0
backports.weakref==1.0.post1
beautifulsoup4==4.8.0
bitarray==1.0.1
bkcharts==0.2
bleach==3.1.0
bokeh==1.3.4
boto==2.49.0
Bottleneck==1.2.1
certifi==2019.9.11
cffi==1.12.3
chardet==3.0.4
Click==7.0
cloudpickle==1.2.2
clyent==1.2.2
cmake==3.20.4
colorama==0.4.1
comtypes==1.1.7
conda==4.7.12
conda-build==3.18.9
conda-package-handling==1.6.0
conda-verify==3.4.2
contextlib2==0.6.0
coreapi==2.3.3
coreschema==0.0.4
cryptography==2.7
cycler==0.10.0
Cython==0.29.13
cytoolz==0.10.0
dask==2.5.2
decorator==4.4.0
defusedxml==0.6.0
distlib==0.3.1
distributed==2.5.2
Django==3.1.5
django-cors-headers==3.6.0
djangorestframework==3.12.2
dlib==19.22.0
docutils==0.15.2
drf-yasg==1.20.0
entrypoints==0.3
et-xmlfile==1.0.1
face-recognition==1.3.0
face-recognition-models==0.3.0
fastcache==1.1.0
filelock==3.0.12
Flask==1.1.1
fsspec==0.5.2
future==0.17.1
gevent==1.4.0
glob2==0.7
greenlet==0.4.15
h5py==2.9.0
HeapDict==1.0.1
html5lib==1.0.1
idna==2.8
imageio==2.6.0
imagesize==1.1.0
importlib-metadata==0.23
inflection==0.5.1
ipykernel==5.1.2
ipython==7.8.0
ipython-genutils==0.2.0
ipywidgets==7.5.1
isort==4.3.21
itsdangerous==1.1.0
itypes==1.2.0
jdcal==1.4.1
jedi==0.15.1
Jinja2==2.10.3
joblib==0.13.2
json5==0.8.5
jsonschema==3.0.2
jupyter==1.0.0
jupyter-client==5.3.3
jupyter-console==6.0.0
jupyter-core==4.5.0
jupyterlab==1.1.4
jupyterlab-server==1.0.6
keyring==18.0.0
kiwisolver==1.1.0
lazy-object-proxy==1.4.2
libarchive-c==2.8
llvmlite==0.29.0
locket==0.2.0
lxml==4.4.1
MarkupSafe==1.1.1
matplotlib==3.1.1
mccabe==0.6.1
menuinst==1.4.16
mistune==0.8.4
mkl-fft==1.0.14
mkl-random==1.1.0
mkl-service==2.3.0
mock==3.0.5
more-itertools==7.2.0
mpmath==1.1.0
msgpack==0.6.1
multipledispatch==0.6.0
navigator-updater==0.2.1
nbconvert==5.6.0
nbformat==4.4.0
networkx==2.3
nltk==3.4.5
node==0.9.25
nose==1.3.7
notebook==6.0.1
numba==0.45.1
numexpr==2.7.0
numpy==1.16.5
numpydoc==0.9.1
odict==1.7.0
olefile==0.46
opencv-python==4.5.2.54
openpyxl==3.0.0
packaging==19.2
pandas==0.25.1
pandocfilters==1.4.2
parso==0.5.1
partd==1.0.0
path.py==12.0.1
pathlib2==2.3.5
patsy==0.5.1
pep8==1.7.1
pickleshare==0.7.5
Pillow==6.2.0
pkginfo==1.5.0.1
pluggy==0.13.0
plumber==1.6
ply==3.11
prometheus-client==0.7.1
prompt-toolkit==2.0.10
psutil==5.6.3
psycopg2==2.8.6
py==1.8.0
pycodestyle==2.5.0
pycosat==0.6.3
pycparser==2.19
pycrypto==2.6.1
pycurl==7.43.0.3
pyflakes==2.1.1
Pygments==2.4.2
pylint==2.4.2
pyodbc==4.0.27
pyOpenSSL==19.0.0
pyparsing==2.4.2
pyreadline==2.1
pyrsistent==0.15.4
PySocks==1.7.1
pytest==5.2.1
pytest-arraydiff==0.3
pytest-astropy==0.5.0
pytest-doctestplus==0.4.0
pytest-openfiles==0.4.0
pytest-remotedata==0.3.2
python-dateutil==2.8.0
pytz==2019.3
PyWavelets==1.0.3
pywin32==223
pywinpty==0.5.5
PyYAML==5.1.2
pyzmq==18.1.0
QtAwesome==0.6.0
qtconsole==4.5.5
QtPy==1.9.0
requests==2.22.0
rope==0.14.0
ruamel-yaml==0.15.46
ruamel.yaml==0.17.9
ruamel.yaml.clib==0.2.2
scikit-image==0.15.0
scikit-learn==0.21.3
scipy==1.3.1
seaborn==0.9.0
Send2Trash==1.5.0
simplegeneric==0.8.1
singledispatch==3.4.0.3
six==1.12.0
snowballstemmer==2.0.0
sortedcollections==1.1.2
sortedcontainers==2.1.0
soupsieve==1.9.3
Sphinx==2.2.0
sphinxcontrib-applehelp==1.0.1
sphinxcontrib-devhelp==1.0.1
sphinxcontrib-htmlhelp==1.0.2
sphinxcontrib-jsmath==1.0.1
sphinxcontrib-qthelp==1.0.2
sphinxcontrib-serializinghtml==1.1.3
sphinxcontrib-websupport==1.1.2
spyder==3.3.6
spyder-kernels==0.5.2
SQLAlchemy==1.3.9
sqlparse==0.4.1
statsmodels==0.10.1
sympy==1.4
tables==3.5.2
tblib==1.4.0
terminado==0.8.2
testpath==0.4.2
toolz==0.10.0
tornado==6.0.3
tqdm==4.36.1
traitlets==4.3.3
typed-ast==1.4.1
typing-extensions==3.10.0.0
unicodecsv==0.14.1
uritemplate==3.0.1
urllib3==1.24.2
virtualenv==20.4.0
virtualenvwrapper-win==1.2.6
wcwidth==0.1.7
webencodings==0.5.1
Werkzeug==0.16.0
widgetsnbextension==3.5.1
win-inet-pton==1.1.0
win-unicode-console==0.5
wincertstore==0.2
wrapt==1.11.2
xlrd==1.2.0
XlsxWriter==1.2.1
xlwings==0.15.10
xlwt==1.3.0
zict==1.0.0
zipp==0.6.0
zope.component==4.6.2
zope.deferredimport==4.3.1
zope.deprecation==4.4.0
zope.event==4.4
zope.hookable==5.0.1
zope.interface==5.1.0
zope.lifecycleevent==4.3
zope.proxy==4.3.5

2.1.2 User Requirements:

The user will require a Laptop or Desktop with webcam facility to capture the attendance.

2.1.3 Environmental Requirements: 

Anaconda Navigator: 

Anaconda Navigator is a desktop graphical user interface (GUI) included in Anaconda® distribution that allows you to launch applications and easily manage conda packages, environments, and channels without using command-line commands. Navigator can search for packages on Anaconda.org or in a local Anaconda Repository. It is available for Windows, macOS, and Linux.

Conda: 

Conda is an open source package management system and environment management system that runs on Windows, macOS and Linux. Conda quickly installs, runs and updates packages and their dependencies. Conda easily creates, saves, loads and switches between environments on your local computer. It was created for Python programs, but it can package and distribute software for any language. Conda as a package manager helps you find and install packages. If you need a package that    requires a different version of Python, you do not need to switch to a different environment manager, because conda is also an environment manager. With just a few commands, you can set up a totally separate environment to run that different version of Python, while continuing to run your usual version of Python in your normal environment.

Django 3.1.5 :
 
Django is a high-level Python Web framework that encourages rapid development and clean, pragmatic design. Built by experienced developers, it takes care of much of the hassle of Web development, so you can focus on writing your app without needing to reinvent the wheel. It’s free and open source.

Jupyter:
 The Jupyter Notebook is an open-source web application that allows you to create and share documents that contain live code, equations, visualizations and narrative text. Uses include: data cleaning and transformation, numerical simulation, statistical modeling, data visualization, machine learning, and much more.

2.2 Design and Architecture:
2.3 Implementation:
Face recognition is really a series of several related problems:
First, look at a picture and find all the faces in it
Second, focus on each face and be able to understand that even if a face is turned in a weird direction or in bad lighting, it is still the same person.
Third, be able to pick out unique features of the face that you can use to tell it apart from other people— like how big the eyes are, how long the face is, etc.
Finally, compare the unique features of that face to all the people you already know to determine the person’s name.
As a human, your brain is wired to do all of this automatically and instantly. In fact, humans are too good at recognizing faces and end up seeing faces in everyday objects. We need to build a pipeline where we solve each step of face recognition separately and pass the result of the current step to the next step. In other words, we will chain together several machine learning algorithms. 
Step 1: Finding all the Faces
The first step in our pipeline is face detection. Obviously we need to locate the faces in a photograph before we can try to tell them apart!
If you’ve used any camera in the last 10 years, you’ve probably seen face detection in action
Face detection is a great feature for cameras. When the camera can automatically pick out faces, it can make sure that all the faces are in focus before it takes the picture. But we’ll use it for a different purpose — finding the areas of the image we want to pass on to the next step in our pipeline.
To find faces in an image, we’ll start by making our image black and white because we don’t need color data to find faces.
Our goal is to figure out how dark the current pixel is compared to the pixels directly surrounding it. Then we want to draw an arrow showing in which direction the image is getting darker.
If you repeat that process for every single pixel in the image, you end up with every pixel being replaced by an arrow. These arrows are called gradients and they show the flow from light to dark across the entire image.
It would be better if we could just see the basic flow of lightness/darkness at a higher level so we could see the basic pattern of the image.
To do this, we’ll break up the image into small squares of 16x16 pixels each. In each square, we’ll count up how many gradients point in each major direction (how many point up, point up-right, point right, etc…). Then we’ll replace that square in the image with the arrow directions that were the strongest.
The end result is we turn the original image into a very simple representation that captures the basic structure of a face in a simple way.
To find faces in this HOG image, all we have to do is find the part of our image that looks the most similar to a known HOG pattern that was extracted from a bunch of other training faces.
Step 2: Posing and Projecting Faces
Now we have to deal with the problem that faces turned in different directions look totally different to a computer.
To account for this, we will try to warp each picture so that the eyes and lips are always in the sample place in the image. This will make it a lot easier for us to compare faces in the next steps.
To do this, we are going to use an algorithm called face landmark estimation.The basic idea is we will come up with 68 specific points (called landmarks) that exist on every face — the top of the chin, the outside edge of each eye, the inner edge of each eyebrow, etc. Then we will train a machine learning algorithm to be able to find these 68 specific points on any face.
Now that we know where the eyes and mouth are, we’ll simply rotate, scale and shear the image so that the eyes and mouth are centered as best as possible. We won’t do any fancy 3d warps because that would introduce distortions into the image. We are only going to use basic image transformations like rotation and scale that preserve parallel lines.
Now no matter how the face is turned, we are able to center the eyes and mouth in roughly the same position in the image. This will make our next step a lot more accurate.
Step 3: Encoding Faces
The simplest approach to face recognition is to directly compare the unknown face we found in Step 2 with all the pictures we have of people that have already been tagged. When we find a previously tagged face that looks very similar to our unknown face, it must be the same person. There’s actually a huge problem with that approach.
What we need is a way to extract a few basic measurements from each face. Then we could measure our unknown face the same way and find the known face with the closest measurements. For example, we might measure the size of each ear, the spacing between the eyes, the length of the nose, etc.
The most reliable way to measure a face
It turns out that the measurements that seem obvious to us humans (like eye color) don’t really make sense to a computer looking at individual pixels in an image. Researchers have discovered that the most accurate approach is to let the computer figure out the measurements to collect itself. Deep learning does a better job than humans at figuring out which parts of a face are important to measure.
The solution is to train a Deep Convolutional Neural Network. But instead of training the network to recognize pictures objects like we did last time, we are going to train it to generate 128 measurements for each face.
The training process works by looking at 3 face images at a time:
Load a training face image of a known person
Load another picture of the same known person
Load a picture of a totally different person
Then the algorithm looks at the measurements it is currently generating for each of those three images. It then tweaks the neural network slightly so that it makes sure the measurements it generates for #1 and #2 are slightly closer while making sure the measurements for #2 and #3 are slightly further apart.
After repeating this step millions of times for millions of images of thousands of different people, the neural network learns to reliably generate 128 measurements for each person. Any ten different pictures of the same person should give roughly the same measurements.
Machine learning people call the 128 measurements of each face an embedding. The idea of reducing complicated raw data like a picture into a list of computer-generated numbers comes up a lot in machine learning (especially in language translation).
Encoding our face image
This process of training a convolutional neural network to output face embeddings requires a lot of data and computer power. Even with an expensive NVidia Tesla video card, it takes about 24 hours of continuous training to get good accuracy.
But once the network has been trained, it can generate measurements for any face, even ones it has never seen before! So this step only needs to be done once. Lucky for us, the fine folks at OpenFace already did this and they published several trained networks which we can directly use. 
Step 4: Finding the person’s name from the encoding
This last step is actually the easiest step in the whole process. All we have to do is find the person in our database of known people who has the closest measurements to our test image.
You can do that by using any basic machine learning classification algorithm. No fancy deep learning tricks are needed. We’ll use a simple linear SVM classifier, but lots of classification algorithms could work.
All we need to do is train a classifier that can take in the measurements from a new test image and tell which known person is the closest match. Running this classifier takes milliseconds. The result of the classifier is the name of the person!


2.4 Graphical User Interface:

1. Login Page


2. Home Page
3. Page - To create a Student



4. To Create batches - Eg. Engineering 4 years



5. List of Batches


6. To Create Branches Eg: Computer , Information Technology , etc





7. List of the Branches - You can see here in the example



8.  A default of 8 semesters in every branch
9. To add subjects in a particular semester giving it a unique subject id and name.



10. Listing all the subjects in a particular semester.





11. To create lectures is a particular semester



12.  All the lectures in a particular semester.



13. Batch list in Attendance Capture.



14. Branch list in Attendance Capture.



15. Semester list in Attendance Capture.



16. Subject list in Attendance Capture.


17. Lecture list in Attendance Capture.



18. To capture a student’s Face.



19  To know which student was present during the lecture- After Capture attendance Record


























2.5 Customer Testing: 

1.We showed our project to students from different colleges and asked for their feedback. 
2. We added the search button in the display batch, semester, students so that it doesn’t become a tedious job to find or create any of these.
3. Added a timestamp column in the final Attendance Report to make the functioning as easy as possible.
4. Added pagination for all tables in all pages, hence making the tables more compact and easy to access.

2.6 Evaluation:

 The face recognition code generates a 128 feature vector array for every face detected by the webcam and we compare that feature vector to other feature vectors present in our database for that particular batch. The code presently shows a 85% accuracy which we plan to make more precise as a part of further scope and development.

3.Conclusion:

In this report we have made an OpenCV face recognition Project along with Attendance Management that will use a webcam to detect faces and record the attendance live in the database. The system has been implemented using the HOG algorithm. The implementation of the Smart Attendance System portrays the existence of an agreement between the appropriate recognition rate and the threshold value. HOG is the authentic and competent face recognition algorithm found in OpenCV for the identification of the students . Also in this method we just have to feed the image . The neural network helps you automatically create 128 feature vectors in a centered face which is then passed through the network to get an optimised result.
We have also learned how face recognition library takes an image input, converts its color scaling to one which is most suitable and then creates 128 feature vectors by aligning the eyes and lips of the face detected, this is done by simple image manipulations. 



4. Further Development And Research:

1. Increasing the database that we have taken into account . 
2. Capturing pictures at multiple instances and then calculating the attendance probability - 
Greater than 50% -present 
Else absent . 
3. No need to press a particular button in order to record the attendance . Self automated attendance taking capability .
4. Attendance taken at variable instances so that there is transparency at the time of recording the attendance. 
5. Increasing the accuracy of the model.
6. Integrating it with a full fledged app like teams of google classroom so that we can increase the scope of the project.




5. REFERENCES :


https://www.pyimagesearch.com/2018/09/24/opencv-face-recognition/

 http://www.ijsrp.org/research-paper-0218/ijsrp-p7433.pdf

https://www.theseus.fi/bitstream/handle/10024/132808/Delbiaggio_Nicolas.pdf?sequence=1&isAllowed=y

https://iopscience.iop.org/article/10.1088/1757-899X/263/4/042095/pdf

 https://towardsdatascience.com/face-recognition-how-lbph-works-90ec258c3d6b

https://medium.com/@ageitgey/machine-learning-is-fun-part-4-modern-face-recognition-with-deep-learning-c3cffc121d78

 https://www.superdatascience.com/blogs/opencv-face-recognition face Recognition based Attendance Management System using Machine Learning Anushka Waingankar1, Akash Upadhyay2, Ruchi Shah3, Nevil Pooniwala4, Prashant Kasambe5

 Automatic Attendance System Using Face Recognition. Ashish Choudhary1,Abhishek Tripathi2,Abhishek Bajaj3,Mudit Rathi4 and B.M Nandini5 1,2,3,4,5 Information Science and Engineering, The National Institue of Engineering

 Face Recognition Based Student Attendance System with OpenCV CH. VINOD KUMAR1 , DR. K. RAJA KUMAR2 1 PG Scholar, Dept of CS& SE, Andhra University, Vishakhapatnam, AP, India. 2Assistant Professor, Dept of CS& SE, Andhra University, Vishakhapatnam, AP, India.

*********************************************************************************************************************************************************************************
 
 

 SCREENSHOTS:
 
 <p align="center">Login Page
  <img src="https://github.com/AryanParekh/Attendace-Capture-and-Management/blob/master/screenshots/Login.PNG" title="Login Page">
</p>
 
 <p align="center">Home Page
  <img src="https://github.com/AryanParekh/Attendace-Capture-and-Management/blob/master/screenshots/HomePage.PNG" title="Home Page">
</p>
 
 <p align="center">Manage - Batch List (Create)
  <img src="https://github.com/AryanParekh/Attendace-Capture-and-Management/blob/master/screenshots/Manage%20-%20Batch%20List%20(Create).PNG" title="Manage - Batch List (Create)">
</p>
 
 <p align="center">Manage - Batch List
  <img src="https://github.com/AryanParekh/Attendace-Capture-and-Management/blob/master/screenshots/Manage%20-%20Batch%20List.PNG" title="Manage - Batch List">
</p>
 
 <p align="center">Manage - Branch List (Create)
  <img src="https://github.com/AryanParekh/Attendace-Capture-and-Management/blob/master/screenshots/Manage%20-%20Branch%20List%20(Create).PNG" title="Manage - Branch List (Create)">
</p>
 
 <p align="center">Manage - Branch List
  <img src="https://github.com/AryanParekh/Attendace-Capture-and-Management/blob/master/screenshots/Manage%20-%20Branch%20List.PNG" title="Manage - Branch List">
</p>
 
 <p align="center">Create a Student
  <img src="https://github.com/AryanParekh/Attendace-Capture-and-Management/blob/master/screenshots/Student%20Create.PNG" title="Create a Student">
</p>
  
 <p align="center">Manage - Semester List
  <img src="https://github.com/AryanParekh/Attendace-Capture-and-Management/blob/master/screenshots/Manage%20-%20Semester%20List.PNG" title="Manage - Semester List">
</p>
 
<p align="center">Manage - Subject List (Create)
  <img src="https://github.com/AryanParekh/Attendace-Capture-and-Management/blob/master/screenshots/Manage%20-%20Subject%20List%20(Create).PNG" title="Manage - Subject List (Create)">
</p>
 
<p align="center">Manage - Subject List
  <img src="https://github.com/AryanParekh/Attendace-Capture-and-Management/blob/master/screenshots/Manage%20-%20Subject%20List.PNG" title="Manage - Subject List">
</p>
 
<p align="center">Manage - Lecture List (Create)
  <img src="https://github.com/AryanParekh/Attendace-Capture-and-Management/blob/master/screenshots/Manage%20-%20Lecture%20List%20(Create).PNG" title="Manage - Lecture List (Create)">
</p>
 
<p align="center">Manage - Lecture List
  <img src="https://github.com/AryanParekh/Attendace-Capture-and-Management/blob/master/screenshots/Manage%20-%20Lecture%20List.PNG" title="Manage - Lecture List">
</p>
 
 <p align="center">Capture - Batch List
  <img src="https://github.com/AryanParekh/Attendace-Capture-and-Management/blob/master/screenshots/Capture%20-%20Batch%20List.PNG" title="Capture - Batch List">
</p>
 
 <p align="center">Capture - Branch List
  <img src="https://github.com/AryanParekh/Attendace-Capture-and-Management/blob/master/screenshots/Capture%20-%20Branch%20List.PNG" title="Capture - Branch List">
</p>
  
 <p align="center">Capture - Semester List
  <img src="https://github.com/AryanParekh/Attendace-Capture-and-Management/blob/master/screenshots/Capture%20-%20Semester%20List.PNG" title="Capture - Semester List">
</p>

<p align="center">Capture - Subject List
  <img src="https://github.com/AryanParekh/Attendace-Capture-and-Management/blob/master/screenshots/Capture%20-%20Subject%20List.PNG" title="Capture - Subject List">
</p>

<p align="center">Capture - Lecture List
  <img src="https://github.com/AryanParekh/Attendace-Capture-and-Management/blob/master/screenshots/Capture%20-%20Lecture%20List.PNG" title="Capture - Lecture List">
</p>
 
 <p align="center">Capture - Student Face
  <img src="https://github.com/AryanParekh/Attendace-Capture-and-Management/blob/master/screenshots/Capture%20-%20Student%20Face.PNG" title="Capture - Student Face">
</p>
 
<p align="center">After Capture - Student List
  <img src="https://github.com/AryanParekh/Attendace-Capture-and-Management/blob/master/screenshots/After%20Capture%20-%20Student%20List.PNG" title="After Capture - Student List">
</p>
 



























THANK YOU
